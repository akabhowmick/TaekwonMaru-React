import {
  O
} from "./chunk-7ZL36RN4.js";
import "./chunk-XJ3M2XN3.js";
import "./chunk-6VWAHX6D.js";
import "./chunk-44YDJCJV.js";
import {
  require_jsx_runtime
} from "./chunk-NRBATONI.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/loadable-image/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/react-intersection-observer/dist/index.mjs
var React = __toESM(require_react(), 1);
var React2 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var observerMap = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
var unsupportedValue = void 0;
function getRootId(root) {
  if (!root) return "0";
  if (RootIds.has(root)) return RootIds.get(root);
  rootId += 1;
  RootIds.set(root, rootId.toString());
  return RootIds.get(root);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter(
    (key) => options[key] !== void 0
  ).map((key) => {
    return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
  }).toString();
}
function createObserver(options) {
  const id = optionsToId(options);
  let instance = observerMap.get(id);
  if (!instance) {
    const elements = /* @__PURE__ */ new Map();
    let thresholds;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        var _a;
        const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
        if (options.trackVisibility && typeof entry.isVisible === "undefined") {
          entry.isVisible = inView;
        }
        (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach((callback) => {
          callback(inView, entry);
        });
      });
    }, options);
    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id,
      observer,
      elements
    };
    observerMap.set(id, instance);
  }
  return instance;
}
function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
  if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
    const bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return () => {
    };
  }
  const { id, observer, elements } = createObserver(options);
  const callbacks = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }
  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks.splice(callbacks.indexOf(callback), 1);
    if (callbacks.length === 0) {
      elements.delete(element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      observerMap.delete(id);
    }
  };
}
function isPlainChildren(props) {
  return typeof props.children !== "function";
}
var InView = class extends React.Component {
  constructor(props) {
    super(props);
    __publicField(this, "node", null);
    __publicField(this, "_unobserveCb", null);
    __publicField(this, "handleNode", (node) => {
      if (this.node) {
        this.unobserve();
        if (!node && !this.props.triggerOnce && !this.props.skip) {
          this.setState({ inView: !!this.props.initialInView, entry: void 0 });
        }
      }
      this.node = node ? node : null;
      this.observeNode();
    });
    __publicField(this, "handleChange", (inView, entry) => {
      if (inView && this.props.triggerOnce) {
        this.unobserve();
      }
      if (!isPlainChildren(this.props)) {
        this.setState({ inView, entry });
      }
      if (this.props.onChange) {
        this.props.onChange(inView, entry);
      }
    });
    this.state = {
      inView: !!props.initialInView,
      entry: void 0
    };
  }
  componentDidMount() {
    this.unobserve();
    this.observeNode();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {
      this.unobserve();
      this.observeNode();
    }
  }
  componentWillUnmount() {
    this.unobserve();
  }
  observeNode() {
    if (!this.node || this.props.skip) return;
    const {
      threshold,
      root,
      rootMargin,
      trackVisibility,
      delay,
      fallbackInView
    } = this.props;
    this._unobserveCb = observe(
      this.node,
      this.handleChange,
      {
        threshold,
        root,
        rootMargin,
        // @ts-ignore
        trackVisibility,
        // @ts-ignore
        delay
      },
      fallbackInView
    );
  }
  unobserve() {
    if (this._unobserveCb) {
      this._unobserveCb();
      this._unobserveCb = null;
    }
  }
  render() {
    const { children } = this.props;
    if (typeof children === "function") {
      const { inView, entry } = this.state;
      return children({ inView, entry, ref: this.handleNode });
    }
    const {
      as,
      triggerOnce,
      threshold,
      root,
      rootMargin,
      onChange,
      skip,
      trackVisibility,
      delay,
      initialInView,
      fallbackInView,
      ...props
    } = this.props;
    return React.createElement(
      as || "div",
      { ref: this.handleNode, ...props },
      children
    );
  }
};

// node_modules/loadable-image/dist/index.esm.js
var import_react = __toESM(require_react());
function c(e2, r2) {
  var t2 = {};
  for (var o in e2) Object.prototype.hasOwnProperty.call(e2, o) && r2.indexOf(o) < 0 && (t2[o] = e2[o]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (o = Object.getOwnPropertySymbols(e2); i2 < o.length; i2++) r2.indexOf(o[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, o[i2]) && (t2[o[i2]] = e2[o[i2]]);
  }
  return t2;
}
var l = (0, import_react.forwardRef)((r2, t2) => {
  var { style: o } = r2, i2 = c(r2, ["style"]);
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ ref: t2 }, i2, { className: `AsyncImage-root ${i2.className}`.trim(), style: Object.assign(Object.assign({}, o), { display: "flex", overflow: "hidden", backgroundRepeat: "no-repeat", boxSizing: "border-box", backgroundSize: "cover", position: "relative" }) }));
});
var b = { top: 0, left: 0, width: "100%", height: "100%", position: "absolute", boxSizing: "border-box" };
var d = (0, import_jsx_runtime.jsx)("div", { className: "AsyncImage-loader", style: { backgroundColor: "#eee" } });
var p = (0, import_jsx_runtime.jsx)("div", { className: "Asyncimage-error", style: { backgroundColor: "#eee" }, children: (0, import_jsx_runtime.jsx)("svg", { fill: "#00000061", viewBox: "0 0 24 24", style: { position: "absolute", inset: 0, width: "50%", height: "50%", margin: "auto" }, children: (0, import_jsx_runtime.jsx)("path", { d: "M21 5c0-1.1-.9-2-2-2H5.83L21 18.17V5zM2.81 2.81 1.39 4.22 3 5.83V19c0 1.1.9 2 2 2h13.17l1.61 1.61 1.41-1.41L2.81 2.81zM6 17l3-4 2.25 3 .82-1.1 2.1 2.1H6z" }) }) });
var u;
!function(e2) {
  e2[e2.LOADING = 0] = "LOADING", e2[e2.LOADED = 1] = "LOADED", e2[e2.FAILED = 2] = "FAILED";
}(u || (u = {}));
var m = (o) => {
  var { error: i2, loader: l2, onLoad: d2, onError: p2, objectFit: m2 = "cover", Transition: g2 = O, timeout: O2 = 1e3, sources: y = [], inView: j } = o, f = c(o, ["error", "loader", "onLoad", "onError", "objectFit", "Transition", "timeout", "sources", "inView"]);
  const [h, v] = (0, import_react.useState)(u.LOADING);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(O, { appear: false, in: h === u.LOADING, timeout: O2, unmountOnExit: true, children: (0, import_react.cloneElement)(l2, { style: Object.assign(Object.assign({}, l2.props.style), b) }) }), j && (0, import_jsx_runtime.jsx)(g2, { in: h === u.LOADED, timeout: O2, children: (0, import_jsx_runtime.jsxs)("picture", { style: b, children: [y.map((r2) => (0, import_jsx_runtime.jsx)("source", Object.assign({}, r2), r2.srcSet)), (0, import_jsx_runtime.jsx)("img", Object.assign({}, f, { className: "AsyncImage-image", style: Object.assign({ objectFit: m2 }, b), onLoad: (e2) => {
    v(u.LOADED), null == d2 || d2(e2);
  }, onError: (e2) => {
    v(u.FAILED), null == p2 || p2(e2);
  } }))] }) }), (0, import_jsx_runtime.jsx)(g2, { in: h === u.FAILED, timeout: O2, mountOnEnter: true, unmountOnExit: true, children: (0, import_react.cloneElement)(i2, { style: Object.assign(Object.assign({}, i2.props.style), b) }) })] });
};
var g = (r2) => {
  var { loader: t2 = d, error: i2 = p, rootMargin: n2 = "600px 0px", objectFit: s2 = "cover", style: a = {}, className: b2 = "" } = r2, u2 = c(r2, ["loader", "error", "rootMargin", "objectFit", "style", "className"]);
  return (0, import_jsx_runtime.jsx)(InView, { rootMargin: n2, triggerOnce: true, children: ({ ref: r3, inView: o }) => {
    var n3;
    return (0, import_jsx_runtime.jsx)(l, { ref: r3, className: b2, style: a, children: (0, import_jsx_runtime.jsx)(m, Object.assign({ error: i2, loader: t2, objectFit: null !== (n3 = a.objectFit) && void 0 !== n3 ? n3 : s2, inView: o }, u2)) });
  } });
};
export {
  g as AsyncImage
};
//# sourceMappingURL=loadable-image.js.map
